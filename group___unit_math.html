<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Unit Conversion and Dimensional Analysis Library: Unit Math</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Unit Conversion and Dimensional Analysis Library
   &#160;<span id="projectnumber">2.1.0</span>
   </div>
   <div id="projectbrief">A compile-time c++14 unit conversion library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Unit Math</div>  </div>
</div><!--header-->
<div class="contents">

<p>Defines a collection of unit-enabled, strongly-typed versions of <code>&lt;cmath&gt;</code> functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac2aeac09538ac3f95fff947c12522faa"><td class="memTemplParams" colspan="2">template&lt;class AngleUnit &gt; </td></tr>
<tr class="memitem:gac2aeac09538ac3f95fff947c12522faa"><td class="memTemplItemLeft" align="right" valign="top">dimensionless::scalar_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_math.html#gac2aeac09538ac3f95fff947c12522faa">units::math::cos</a> (const AngleUnit angle) noexcept</td></tr>
<tr class="memdesc:gac2aeac09538ac3f95fff947c12522faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute cosine.  <a href="group___unit_math.html#gac2aeac09538ac3f95fff947c12522faa">More...</a><br /></td></tr>
<tr class="separator:gac2aeac09538ac3f95fff947c12522faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0a50351f8f51550d00e9831b60e1850"><td class="memTemplParams" colspan="2">template&lt;class AngleUnit &gt; </td></tr>
<tr class="memitem:gaf0a50351f8f51550d00e9831b60e1850"><td class="memTemplItemLeft" align="right" valign="top">dimensionless::scalar_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_math.html#gaf0a50351f8f51550d00e9831b60e1850">units::math::sin</a> (const AngleUnit angle) noexcept</td></tr>
<tr class="memdesc:gaf0a50351f8f51550d00e9831b60e1850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute sine.  <a href="group___unit_math.html#gaf0a50351f8f51550d00e9831b60e1850">More...</a><br /></td></tr>
<tr class="separator:gaf0a50351f8f51550d00e9831b60e1850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a0bd68dee584d4b0b12c49bec0706c1"><td class="memTemplParams" colspan="2">template&lt;class AngleUnit &gt; </td></tr>
<tr class="memitem:ga4a0bd68dee584d4b0b12c49bec0706c1"><td class="memTemplItemLeft" align="right" valign="top">dimensionless::scalar_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_math.html#ga4a0bd68dee584d4b0b12c49bec0706c1">units::math::tan</a> (const AngleUnit angle) noexcept</td></tr>
<tr class="memdesc:ga4a0bd68dee584d4b0b12c49bec0706c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute tangent.  <a href="group___unit_math.html#ga4a0bd68dee584d4b0b12c49bec0706c1">More...</a><br /></td></tr>
<tr class="separator:ga4a0bd68dee584d4b0b12c49bec0706c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83597409663ca3af0892acf87844af49"><td class="memTemplParams" colspan="2">template&lt;class ScalarUnit &gt; </td></tr>
<tr class="memitem:ga83597409663ca3af0892acf87844af49"><td class="memTemplItemLeft" align="right" valign="top">angle::radian_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_math.html#ga83597409663ca3af0892acf87844af49">units::math::acos</a> (const ScalarUnit x) noexcept</td></tr>
<tr class="memdesc:ga83597409663ca3af0892acf87844af49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute arc cosine.  <a href="group___unit_math.html#ga83597409663ca3af0892acf87844af49">More...</a><br /></td></tr>
<tr class="separator:ga83597409663ca3af0892acf87844af49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6070806b3322a08af3ee934731ddcc31"><td class="memTemplParams" colspan="2">template&lt;class ScalarUnit &gt; </td></tr>
<tr class="memitem:ga6070806b3322a08af3ee934731ddcc31"><td class="memTemplItemLeft" align="right" valign="top">angle::radian_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_math.html#ga6070806b3322a08af3ee934731ddcc31">units::math::asin</a> (const ScalarUnit x) noexcept</td></tr>
<tr class="memdesc:ga6070806b3322a08af3ee934731ddcc31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute arc sine.  <a href="group___unit_math.html#ga6070806b3322a08af3ee934731ddcc31">More...</a><br /></td></tr>
<tr class="separator:ga6070806b3322a08af3ee934731ddcc31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8c42d9f521a8909fe92caeb674c30bb"><td class="memTemplParams" colspan="2">template&lt;class ScalarUnit &gt; </td></tr>
<tr class="memitem:gab8c42d9f521a8909fe92caeb674c30bb"><td class="memTemplItemLeft" align="right" valign="top">angle::radian_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_math.html#gab8c42d9f521a8909fe92caeb674c30bb">units::math::atan</a> (const ScalarUnit x) noexcept</td></tr>
<tr class="memdesc:gab8c42d9f521a8909fe92caeb674c30bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute arc tangent.  <a href="group___unit_math.html#gab8c42d9f521a8909fe92caeb674c30bb">More...</a><br /></td></tr>
<tr class="separator:gab8c42d9f521a8909fe92caeb674c30bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga845823260245af2abc83d2cf47f6e74b"><td class="memTemplParams" colspan="2">template&lt;class Y , class X &gt; </td></tr>
<tr class="memitem:ga845823260245af2abc83d2cf47f6e74b"><td class="memTemplItemLeft" align="right" valign="top">angle::radian_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_math.html#ga845823260245af2abc83d2cf47f6e74b">units::math::atan2</a> (const Y y, const X x) noexcept</td></tr>
<tr class="memdesc:ga845823260245af2abc83d2cf47f6e74b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute arc tangent with two parameters.  <a href="group___unit_math.html#ga845823260245af2abc83d2cf47f6e74b">More...</a><br /></td></tr>
<tr class="separator:ga845823260245af2abc83d2cf47f6e74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0c26f165fe864ceb9f2af667b3cb66d"><td class="memTemplParams" colspan="2">template&lt;class AngleUnit &gt; </td></tr>
<tr class="memitem:gab0c26f165fe864ceb9f2af667b3cb66d"><td class="memTemplItemLeft" align="right" valign="top">dimensionless::scalar_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_math.html#gab0c26f165fe864ceb9f2af667b3cb66d">units::math::cosh</a> (const AngleUnit angle) noexcept</td></tr>
<tr class="memdesc:gab0c26f165fe864ceb9f2af667b3cb66d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute hyperbolic cosine.  <a href="group___unit_math.html#gab0c26f165fe864ceb9f2af667b3cb66d">More...</a><br /></td></tr>
<tr class="separator:gab0c26f165fe864ceb9f2af667b3cb66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38584a9aa9ecbcf455f1a75b23fc8495"><td class="memTemplParams" colspan="2">template&lt;class AngleUnit &gt; </td></tr>
<tr class="memitem:ga38584a9aa9ecbcf455f1a75b23fc8495"><td class="memTemplItemLeft" align="right" valign="top">dimensionless::scalar_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_math.html#ga38584a9aa9ecbcf455f1a75b23fc8495">units::math::sinh</a> (const AngleUnit angle) noexcept</td></tr>
<tr class="memdesc:ga38584a9aa9ecbcf455f1a75b23fc8495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute hyperbolic sine.  <a href="group___unit_math.html#ga38584a9aa9ecbcf455f1a75b23fc8495">More...</a><br /></td></tr>
<tr class="separator:ga38584a9aa9ecbcf455f1a75b23fc8495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca6a60340c678dcce1c2e4afc52f3c9d"><td class="memTemplParams" colspan="2">template&lt;class AngleUnit &gt; </td></tr>
<tr class="memitem:gaca6a60340c678dcce1c2e4afc52f3c9d"><td class="memTemplItemLeft" align="right" valign="top">dimensionless::scalar_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_math.html#gaca6a60340c678dcce1c2e4afc52f3c9d">units::math::tanh</a> (const AngleUnit angle) noexcept</td></tr>
<tr class="memdesc:gaca6a60340c678dcce1c2e4afc52f3c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute hyperbolic tangent.  <a href="group___unit_math.html#gaca6a60340c678dcce1c2e4afc52f3c9d">More...</a><br /></td></tr>
<tr class="separator:gaca6a60340c678dcce1c2e4afc52f3c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29860e26570c2decc2bb8710c1ae911c"><td class="memTemplParams" colspan="2">template&lt;class ScalarUnit &gt; </td></tr>
<tr class="memitem:ga29860e26570c2decc2bb8710c1ae911c"><td class="memTemplItemLeft" align="right" valign="top">angle::radian_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_math.html#ga29860e26570c2decc2bb8710c1ae911c">units::math::acosh</a> (const ScalarUnit x) noexcept</td></tr>
<tr class="memdesc:ga29860e26570c2decc2bb8710c1ae911c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute arc hyperbolic cosine.  <a href="group___unit_math.html#ga29860e26570c2decc2bb8710c1ae911c">More...</a><br /></td></tr>
<tr class="separator:ga29860e26570c2decc2bb8710c1ae911c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffaf53aeed1529243100d0922bdce834"><td class="memTemplParams" colspan="2">template&lt;class ScalarUnit &gt; </td></tr>
<tr class="memitem:gaffaf53aeed1529243100d0922bdce834"><td class="memTemplItemLeft" align="right" valign="top">angle::radian_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_math.html#gaffaf53aeed1529243100d0922bdce834">units::math::asinh</a> (const ScalarUnit x) noexcept</td></tr>
<tr class="memdesc:gaffaf53aeed1529243100d0922bdce834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute arc hyperbolic sine.  <a href="group___unit_math.html#gaffaf53aeed1529243100d0922bdce834">More...</a><br /></td></tr>
<tr class="separator:gaffaf53aeed1529243100d0922bdce834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8262877321f58e73f76a90e1317e1608"><td class="memTemplParams" colspan="2">template&lt;class ScalarUnit &gt; </td></tr>
<tr class="memitem:ga8262877321f58e73f76a90e1317e1608"><td class="memTemplItemLeft" align="right" valign="top">angle::radian_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_math.html#ga8262877321f58e73f76a90e1317e1608">units::math::atanh</a> (const ScalarUnit x) noexcept</td></tr>
<tr class="memdesc:ga8262877321f58e73f76a90e1317e1608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute arc hyperbolic tangent.  <a href="group___unit_math.html#ga8262877321f58e73f76a90e1317e1608">More...</a><br /></td></tr>
<tr class="separator:ga8262877321f58e73f76a90e1317e1608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37ffdd257c05eb6916d62bfbbc0890e2"><td class="memTemplParams" colspan="2">template&lt;class ScalarUnit &gt; </td></tr>
<tr class="memitem:ga37ffdd257c05eb6916d62bfbbc0890e2"><td class="memTemplItemLeft" align="right" valign="top">dimensionless::scalar_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_math.html#ga37ffdd257c05eb6916d62bfbbc0890e2">units::math::exp</a> (const ScalarUnit x) noexcept</td></tr>
<tr class="memdesc:ga37ffdd257c05eb6916d62bfbbc0890e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute exponential function.  <a href="group___unit_math.html#ga37ffdd257c05eb6916d62bfbbc0890e2">More...</a><br /></td></tr>
<tr class="separator:ga37ffdd257c05eb6916d62bfbbc0890e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed3e6783dc5ab1dda006913aa53f17c8"><td class="memTemplParams" colspan="2">template&lt;class ScalarUnit &gt; </td></tr>
<tr class="memitem:gaed3e6783dc5ab1dda006913aa53f17c8"><td class="memTemplItemLeft" align="right" valign="top">dimensionless::scalar_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_math.html#gaed3e6783dc5ab1dda006913aa53f17c8">units::math::log</a> (const ScalarUnit x) noexcept</td></tr>
<tr class="memdesc:gaed3e6783dc5ab1dda006913aa53f17c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute natural logarithm.  <a href="group___unit_math.html#gaed3e6783dc5ab1dda006913aa53f17c8">More...</a><br /></td></tr>
<tr class="separator:gaed3e6783dc5ab1dda006913aa53f17c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf02e920d1b57574f1c8ae3974d1e3c80"><td class="memTemplParams" colspan="2">template&lt;class ScalarUnit &gt; </td></tr>
<tr class="memitem:gaf02e920d1b57574f1c8ae3974d1e3c80"><td class="memTemplItemLeft" align="right" valign="top">dimensionless::scalar_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_math.html#gaf02e920d1b57574f1c8ae3974d1e3c80">units::math::log10</a> (const ScalarUnit x) noexcept</td></tr>
<tr class="memdesc:gaf02e920d1b57574f1c8ae3974d1e3c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute common logarithm.  <a href="group___unit_math.html#gaf02e920d1b57574f1c8ae3974d1e3c80">More...</a><br /></td></tr>
<tr class="separator:gaf02e920d1b57574f1c8ae3974d1e3c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84d1ea9cad48f0b77cf892633240e4a6"><td class="memTemplParams" colspan="2">template&lt;class ScalarUnit &gt; </td></tr>
<tr class="memitem:ga84d1ea9cad48f0b77cf892633240e4a6"><td class="memTemplItemLeft" align="right" valign="top">dimensionless::scalar_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_math.html#ga84d1ea9cad48f0b77cf892633240e4a6">units::math::modf</a> (const ScalarUnit x, ScalarUnit *intpart) noexcept</td></tr>
<tr class="memdesc:ga84d1ea9cad48f0b77cf892633240e4a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Break into fractional and integral parts.  <a href="group___unit_math.html#ga84d1ea9cad48f0b77cf892633240e4a6">More...</a><br /></td></tr>
<tr class="separator:ga84d1ea9cad48f0b77cf892633240e4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga872856d20626a6b912cc97b63bc95c89"><td class="memTemplParams" colspan="2">template&lt;class ScalarUnit &gt; </td></tr>
<tr class="memitem:ga872856d20626a6b912cc97b63bc95c89"><td class="memTemplItemLeft" align="right" valign="top">dimensionless::scalar_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_math.html#ga872856d20626a6b912cc97b63bc95c89">units::math::exp2</a> (const ScalarUnit x) noexcept</td></tr>
<tr class="memdesc:ga872856d20626a6b912cc97b63bc95c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute binary exponential function.  <a href="group___unit_math.html#ga872856d20626a6b912cc97b63bc95c89">More...</a><br /></td></tr>
<tr class="separator:ga872856d20626a6b912cc97b63bc95c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9aee32f9e268b7135c66fc1fb887f44a"><td class="memTemplParams" colspan="2">template&lt;class ScalarUnit &gt; </td></tr>
<tr class="memitem:ga9aee32f9e268b7135c66fc1fb887f44a"><td class="memTemplItemLeft" align="right" valign="top">dimensionless::scalar_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_math.html#ga9aee32f9e268b7135c66fc1fb887f44a">units::math::expm1</a> (const ScalarUnit x) noexcept</td></tr>
<tr class="memdesc:ga9aee32f9e268b7135c66fc1fb887f44a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute exponential minus one.  <a href="group___unit_math.html#ga9aee32f9e268b7135c66fc1fb887f44a">More...</a><br /></td></tr>
<tr class="separator:ga9aee32f9e268b7135c66fc1fb887f44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef69e3da7b1cf820853dc8bb5043e1e7"><td class="memTemplParams" colspan="2">template&lt;class ScalarUnit &gt; </td></tr>
<tr class="memitem:gaef69e3da7b1cf820853dc8bb5043e1e7"><td class="memTemplItemLeft" align="right" valign="top">dimensionless::scalar_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_math.html#gaef69e3da7b1cf820853dc8bb5043e1e7">units::math::log1p</a> (const ScalarUnit x) noexcept</td></tr>
<tr class="memdesc:gaef69e3da7b1cf820853dc8bb5043e1e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute logarithm plus one.  <a href="group___unit_math.html#gaef69e3da7b1cf820853dc8bb5043e1e7">More...</a><br /></td></tr>
<tr class="separator:gaef69e3da7b1cf820853dc8bb5043e1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac19a3f10ebced4d7760193130ed220fa"><td class="memTemplParams" colspan="2">template&lt;class ScalarUnit &gt; </td></tr>
<tr class="memitem:gac19a3f10ebced4d7760193130ed220fa"><td class="memTemplItemLeft" align="right" valign="top">dimensionless::scalar_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_math.html#gac19a3f10ebced4d7760193130ed220fa">units::math::log2</a> (const ScalarUnit x) noexcept</td></tr>
<tr class="memdesc:gac19a3f10ebced4d7760193130ed220fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute binary logarithm.  <a href="group___unit_math.html#gac19a3f10ebced4d7760193130ed220fa">More...</a><br /></td></tr>
<tr class="separator:gac19a3f10ebced4d7760193130ed220fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c190a6f34676262b59c06423e27e1d4"><td class="memTemplParams" colspan="2">template&lt;class UnitType , std::enable_if_t&lt; units::traits::has_linear_scale&lt; UnitType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ga2c190a6f34676262b59c06423e27e1d4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_math.html#ga2c190a6f34676262b59c06423e27e1d4">units::math::sqrt</a> (const UnitType &amp;value) noexcept-&gt; unit_t&lt; square_root&lt; typename units::traits::unit_t_traits&lt; UnitType &gt;::unit_type &gt;, typename units::traits::unit_t_traits&lt; UnitType &gt;::underlying_type, linear_scale &gt;</td></tr>
<tr class="memdesc:ga2c190a6f34676262b59c06423e27e1d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the square root of <em>value</em>  <a href="group___unit_math.html#ga2c190a6f34676262b59c06423e27e1d4">More...</a><br /></td></tr>
<tr class="separator:ga2c190a6f34676262b59c06423e27e1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3162ba1ab8f84bcd2d17cbe60769b851"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeLhs , class UnitTypeRhs , std::enable_if_t&lt; units::traits::has_linear_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ga3162ba1ab8f84bcd2d17cbe60769b851"><td class="memTemplItemLeft" align="right" valign="top">UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_math.html#ga3162ba1ab8f84bcd2d17cbe60769b851">units::math::hypot</a> (const UnitTypeLhs &amp;x, const UnitTypeRhs &amp;y)</td></tr>
<tr class="memdesc:ga3162ba1ab8f84bcd2d17cbe60769b851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of the sum-of-squares of x and y.  <a href="group___unit_math.html#ga3162ba1ab8f84bcd2d17cbe60769b851">More...</a><br /></td></tr>
<tr class="separator:ga3162ba1ab8f84bcd2d17cbe60769b851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafeea9aa149ff1d941ed830ec389bf7f4"><td class="memTemplParams" colspan="2">template&lt;class UnitType , class  = std::enable_if_t&lt;traits::is_unit_t&lt;UnitType&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:gafeea9aa149ff1d941ed830ec389bf7f4"><td class="memTemplItemLeft" align="right" valign="top">UnitType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_math.html#gafeea9aa149ff1d941ed830ec389bf7f4">units::math::ceil</a> (const UnitType x) noexcept</td></tr>
<tr class="memdesc:gafeea9aa149ff1d941ed830ec389bf7f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round up value.  <a href="group___unit_math.html#gafeea9aa149ff1d941ed830ec389bf7f4">More...</a><br /></td></tr>
<tr class="separator:gafeea9aa149ff1d941ed830ec389bf7f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7fa514c186141cb9d3fcf824fd41a37"><td class="memTemplParams" colspan="2">template&lt;class UnitType , class  = std::enable_if_t&lt;traits::is_unit_t&lt;UnitType&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:gad7fa514c186141cb9d3fcf824fd41a37"><td class="memTemplItemLeft" align="right" valign="top">UnitType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_math.html#gad7fa514c186141cb9d3fcf824fd41a37">units::math::floor</a> (const UnitType x) noexcept</td></tr>
<tr class="memdesc:gad7fa514c186141cb9d3fcf824fd41a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round down value.  <a href="group___unit_math.html#gad7fa514c186141cb9d3fcf824fd41a37">More...</a><br /></td></tr>
<tr class="separator:gad7fa514c186141cb9d3fcf824fd41a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50270995c6f9ca902fcdc2daf8edc784"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeLhs , class UnitTypeRhs , class  = std::enable_if_t&lt;traits::is_unit_t&lt;UnitTypeLhs&gt;::value &amp;&amp; traits::is_unit_t&lt;UnitTypeRhs&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga50270995c6f9ca902fcdc2daf8edc784"><td class="memTemplItemLeft" align="right" valign="top">UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_math.html#ga50270995c6f9ca902fcdc2daf8edc784">units::math::fmod</a> (const UnitTypeLhs numer, const UnitTypeRhs denom) noexcept</td></tr>
<tr class="memdesc:ga50270995c6f9ca902fcdc2daf8edc784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute remainder of division.  <a href="group___unit_math.html#ga50270995c6f9ca902fcdc2daf8edc784">More...</a><br /></td></tr>
<tr class="separator:ga50270995c6f9ca902fcdc2daf8edc784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0019fd57476802def84991c48fe8e66"><td class="memTemplParams" colspan="2">template&lt;class UnitType , class  = std::enable_if_t&lt;traits::is_unit_t&lt;UnitType&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:gae0019fd57476802def84991c48fe8e66"><td class="memTemplItemLeft" align="right" valign="top">UnitType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_math.html#gae0019fd57476802def84991c48fe8e66">units::math::trunc</a> (const UnitType x) noexcept</td></tr>
<tr class="memdesc:gae0019fd57476802def84991c48fe8e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate value.  <a href="group___unit_math.html#gae0019fd57476802def84991c48fe8e66">More...</a><br /></td></tr>
<tr class="separator:gae0019fd57476802def84991c48fe8e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e417de9376e1fc58cd07a8465c7e9c6"><td class="memTemplParams" colspan="2">template&lt;class UnitType , class  = std::enable_if_t&lt;traits::is_unit_t&lt;UnitType&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga3e417de9376e1fc58cd07a8465c7e9c6"><td class="memTemplItemLeft" align="right" valign="top">UnitType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_math.html#ga3e417de9376e1fc58cd07a8465c7e9c6">units::math::round</a> (const UnitType x) noexcept</td></tr>
<tr class="memdesc:ga3e417de9376e1fc58cd07a8465c7e9c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round to nearest.  <a href="group___unit_math.html#ga3e417de9376e1fc58cd07a8465c7e9c6">More...</a><br /></td></tr>
<tr class="separator:ga3e417de9376e1fc58cd07a8465c7e9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade1a8bde53a3516371efc5b0bf026e1d"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeLhs , class UnitTypeRhs , class  = std::enable_if_t&lt;traits::is_unit_t&lt;UnitTypeLhs&gt;::value &amp;&amp; traits::is_unit_t&lt;UnitTypeRhs&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:gade1a8bde53a3516371efc5b0bf026e1d"><td class="memTemplItemLeft" align="right" valign="top">UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_math.html#gade1a8bde53a3516371efc5b0bf026e1d">units::math::copysign</a> (const UnitTypeLhs x, const UnitTypeRhs y) noexcept</td></tr>
<tr class="memdesc:gade1a8bde53a3516371efc5b0bf026e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy sign.  <a href="group___unit_math.html#gade1a8bde53a3516371efc5b0bf026e1d">More...</a><br /></td></tr>
<tr class="separator:gade1a8bde53a3516371efc5b0bf026e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75fe15cca375d6f73fd1b797d491119d"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeLhs , class UnitTypeRhs , class  = std::enable_if_t&lt;traits::is_unit_t&lt;UnitTypeLhs&gt;::value &amp;&amp; traits::is_unit_t&lt;UnitTypeRhs&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga75fe15cca375d6f73fd1b797d491119d"><td class="memTemplItemLeft" align="right" valign="top">UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_math.html#ga75fe15cca375d6f73fd1b797d491119d">units::math::fdim</a> (const UnitTypeLhs x, const UnitTypeRhs y) noexcept</td></tr>
<tr class="memdesc:ga75fe15cca375d6f73fd1b797d491119d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positive difference.  <a href="group___unit_math.html#ga75fe15cca375d6f73fd1b797d491119d">More...</a><br /></td></tr>
<tr class="separator:ga75fe15cca375d6f73fd1b797d491119d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga133b8c692d6dbf2d19f27adb13ce6ecf"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeLhs , class UnitTypeRhs , class  = std::enable_if_t&lt;traits::is_unit_t&lt;UnitTypeLhs&gt;::value &amp;&amp; traits::is_unit_t&lt;UnitTypeRhs&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga133b8c692d6dbf2d19f27adb13ce6ecf"><td class="memTemplItemLeft" align="right" valign="top">UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_math.html#ga133b8c692d6dbf2d19f27adb13ce6ecf">units::math::fmax</a> (const UnitTypeLhs x, const UnitTypeRhs y) noexcept</td></tr>
<tr class="memdesc:ga133b8c692d6dbf2d19f27adb13ce6ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value.  <a href="group___unit_math.html#ga133b8c692d6dbf2d19f27adb13ce6ecf">More...</a><br /></td></tr>
<tr class="separator:ga133b8c692d6dbf2d19f27adb13ce6ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c7353469775440d04f98655e3a9e065"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeLhs , class UnitTypeRhs , class  = std::enable_if_t&lt;traits::is_unit_t&lt;UnitTypeLhs&gt;::value &amp;&amp; traits::is_unit_t&lt;UnitTypeRhs&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga2c7353469775440d04f98655e3a9e065"><td class="memTemplItemLeft" align="right" valign="top">UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_math.html#ga2c7353469775440d04f98655e3a9e065">units::math::fmin</a> (const UnitTypeLhs x, const UnitTypeRhs y) noexcept</td></tr>
<tr class="memdesc:ga2c7353469775440d04f98655e3a9e065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum value.  <a href="group___unit_math.html#ga2c7353469775440d04f98655e3a9e065">More...</a><br /></td></tr>
<tr class="separator:ga2c7353469775440d04f98655e3a9e065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae0bd34663a2828665567af99a97fb24"><td class="memTemplParams" colspan="2">template&lt;class UnitType , class  = std::enable_if_t&lt;traits::is_unit_t&lt;UnitType&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:gaae0bd34663a2828665567af99a97fb24"><td class="memTemplItemLeft" align="right" valign="top">UnitType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_math.html#gaae0bd34663a2828665567af99a97fb24">units::math::fabs</a> (const UnitType x) noexcept</td></tr>
<tr class="memdesc:gaae0bd34663a2828665567af99a97fb24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute absolute value.  <a href="group___unit_math.html#gaae0bd34663a2828665567af99a97fb24">More...</a><br /></td></tr>
<tr class="separator:gaae0bd34663a2828665567af99a97fb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dd8baba0276c51feeb892983d41ef47"><td class="memTemplParams" colspan="2">template&lt;class UnitType , class  = std::enable_if_t&lt;traits::is_unit_t&lt;UnitType&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga1dd8baba0276c51feeb892983d41ef47"><td class="memTemplItemLeft" align="right" valign="top">UnitType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_math.html#ga1dd8baba0276c51feeb892983d41ef47">units::math::abs</a> (const UnitType x) noexcept</td></tr>
<tr class="memdesc:ga1dd8baba0276c51feeb892983d41ef47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute absolute value.  <a href="group___unit_math.html#ga1dd8baba0276c51feeb892983d41ef47">More...</a><br /></td></tr>
<tr class="separator:ga1dd8baba0276c51feeb892983d41ef47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga007637a66a15b39d44af325ddf8d754c"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeLhs , class UnitMultiply , class UnitAdd , class  = std::enable_if_t&lt;traits::is_unit_t&lt;UnitTypeLhs&gt;::value &amp;&amp; traits::is_unit_t&lt;UnitMultiply&gt;::value &amp;&amp; traits::is_unit_t&lt;UnitAdd&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga007637a66a15b39d44af325ddf8d754c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_math.html#ga007637a66a15b39d44af325ddf8d754c">units::math::fma</a> (const UnitTypeLhs x, const UnitMultiply y, const UnitAdd z) noexcept-&gt; decltype(x *y)</td></tr>
<tr class="memdesc:ga007637a66a15b39d44af325ddf8d754c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-add.  <a href="group___unit_math.html#ga007637a66a15b39d44af325ddf8d754c">More...</a><br /></td></tr>
<tr class="separator:ga007637a66a15b39d44af325ddf8d754c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Defines a collection of unit-enabled, strongly-typed versions of <code>&lt;cmath&gt;</code> functions. </p>
<p>Includes most c++11 extensions. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga1dd8baba0276c51feeb892983d41ef47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UnitType , class  = std::enable_if_t&lt;traits::is_unit_t&lt;UnitType&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UnitType units::math::abs </td>
          <td>(</td>
          <td class="paramtype">const UnitType&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute absolute value. </p>
<p>Returns the absolute value of x, i.e. |x|. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Value whose absolute value is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The absolute value of x. </dd></dl>

</div>
</div>
<a class="anchor" id="ga83597409663ca3af0892acf87844af49"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ScalarUnit &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">angle::radian_t units::math::acos </td>
          <td>(</td>
          <td class="paramtype">const ScalarUnit&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute arc cosine. </p>
<p>Returns the principal value of the arc cosine of x, expressed in radians. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Value whose arc cosine is computed, in the interval [-1,+1]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Principal arc cosine of x, in the interval [0,pi] radians. </dd></dl>

</div>
</div>
<a class="anchor" id="ga29860e26570c2decc2bb8710c1ae911c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ScalarUnit &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">angle::radian_t units::math::acosh </td>
          <td>(</td>
          <td class="paramtype">const ScalarUnit&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute arc hyperbolic cosine. </p>
<p>Returns the nonnegative arc hyperbolic cosine of x, expressed in radians. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Value whose arc hyperbolic cosine is computed. If the argument is less than 1, a domain error occurs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nonnegative arc hyperbolic cosine of x, in the interval [0,+INFINITY] radians. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6070806b3322a08af3ee934731ddcc31"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ScalarUnit &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">angle::radian_t units::math::asin </td>
          <td>(</td>
          <td class="paramtype">const ScalarUnit&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute arc sine. </p>
<p>Returns the principal value of the arc sine of x, expressed in radians. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Value whose arc sine is computed, in the interval [-1,+1]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Principal arc sine of x, in the interval [-pi/2,+pi/2] radians. </dd></dl>

</div>
</div>
<a class="anchor" id="gaffaf53aeed1529243100d0922bdce834"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ScalarUnit &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">angle::radian_t units::math::asinh </td>
          <td>(</td>
          <td class="paramtype">const ScalarUnit&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute arc hyperbolic sine. </p>
<p>Returns the arc hyperbolic sine of x, expressed in radians. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Value whose arc hyperbolic sine is computed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Arc hyperbolic sine of x, in radians. </dd></dl>

</div>
</div>
<a class="anchor" id="gab8c42d9f521a8909fe92caeb674c30bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ScalarUnit &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">angle::radian_t units::math::atan </td>
          <td>(</td>
          <td class="paramtype">const ScalarUnit&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute arc tangent. </p>
<p>Returns the principal value of the arc tangent of x, expressed in radians. Notice that because of the sign ambiguity, the function cannot determine with certainty in which quadrant the angle falls only by its tangent value. See atan2 for an alternative that takes a fractional argument instead. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">AngleUnit</td><td>any <code><a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a></code> type of <code>catgeory::angle_unit</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Value whose arc tangent is computed, in the interval [-1,+1]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Principal arc tangent of x, in the interval [-pi/2,+pi/2] radians. </dd></dl>

</div>
</div>
<a class="anchor" id="ga845823260245af2abc83d2cf47f6e74b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">angle::radian_t units::math::atan2 </td>
          <td>(</td>
          <td class="paramtype">const Y&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute arc tangent with two parameters. </p>
<p>To compute the value, the function takes into account the sign of both arguments in order to determine the quadrant. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>y-component of the triangle expressed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>x-component of the triangle expressed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the principal value of the arc tangent of <em>y/x</em>, expressed in radians. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8262877321f58e73f76a90e1317e1608"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ScalarUnit &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">angle::radian_t units::math::atanh </td>
          <td>(</td>
          <td class="paramtype">const ScalarUnit&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute arc hyperbolic tangent. </p>
<p>Returns the arc hyperbolic tangent of x, expressed in radians. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Value whose arc hyperbolic tangent is computed, in the interval [-1,+1]. If the argument is out of this interval, a domain error occurs. For values of -1 and +1, a pole error may occur. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>units::angle::radian_t </dd></dl>

</div>
</div>
<a class="anchor" id="gafeea9aa149ff1d941ed830ec389bf7f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UnitType , class  = std::enable_if_t&lt;traits::is_unit_t&lt;UnitType&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UnitType units::math::ceil </td>
          <td>(</td>
          <td class="paramtype">const UnitType&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Round up value. </p>
<p>Rounds x upward, returning the smallest integral value that is not less than x. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Unit value to round up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest integral value that is not less than x. </dd></dl>

</div>
</div>
<a class="anchor" id="gade1a8bde53a3516371efc5b0bf026e1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UnitTypeLhs , class UnitTypeRhs , class  = std::enable_if_t&lt;traits::is_unit_t&lt;UnitTypeLhs&gt;::value &amp;&amp; traits::is_unit_t&lt;UnitTypeRhs&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UnitTypeLhs units::math::copysign </td>
          <td>(</td>
          <td class="paramtype">const UnitTypeLhs&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnitTypeRhs&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy sign. </p>
<p>Returns a value with the magnitude and dimension of x, and the sign of y. Values x and y do not have to be compatible units. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Value with the magnitude of the resulting value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Value with the sign of the resulting value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value with the magnitude and dimension of x, and the sign of y. </dd></dl>

</div>
</div>
<a class="anchor" id="gac2aeac09538ac3f95fff947c12522faa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AngleUnit &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dimensionless::scalar_t units::math::cos </td>
          <td>(</td>
          <td class="paramtype">const AngleUnit&#160;</td>
          <td class="paramname"><em>angle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute cosine. </p>
<p>The input value can be in any unit of angle, including radians or degrees. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">AngleUnit</td><td>any <code><a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a></code> type of <code>catgeory::angle_unit</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">angle</td><td>angle to compute the cosine of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the cosine of <em>angle</em> </dd></dl>

</div>
</div>
<a class="anchor" id="gab0c26f165fe864ceb9f2af667b3cb66d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AngleUnit &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dimensionless::scalar_t units::math::cosh </td>
          <td>(</td>
          <td class="paramtype">const AngleUnit&#160;</td>
          <td class="paramname"><em>angle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute hyperbolic cosine. </p>
<p>The input value can be in any unit of angle, including radians or degrees. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">AngleUnit</td><td>any <code><a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a></code> type of <code>catgeory::angle_unit</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">angle</td><td>angle to compute the hyperbolic cosine of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the hyperbolic cosine of <em>angle</em> </dd></dl>

</div>
</div>
<a class="anchor" id="ga37ffdd257c05eb6916d62bfbbc0890e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ScalarUnit &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dimensionless::scalar_t units::math::exp </td>
          <td>(</td>
          <td class="paramtype">const ScalarUnit&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute exponential function. </p>
<p>Returns the base-e exponential function of x, which is e raised to the power x: ex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>scalar value of the exponent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Exponential value of x. If the magnitude of the result is too large to be represented by a value of the return type, the function returns HUGE_VAL (or HUGE_VALF or HUGE_VALL) with the proper sign, and an overflow range error occurs </dd></dl>

</div>
</div>
<a class="anchor" id="ga872856d20626a6b912cc97b63bc95c89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ScalarUnit &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dimensionless::scalar_t units::math::exp2 </td>
          <td>(</td>
          <td class="paramtype">const ScalarUnit&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute binary exponential function. </p>
<p>Returns the base-2 exponential function of x, which is 2 raised to the power x: 2^x. 2param[in] x Value of the exponent. </p><dl class="section return"><dt>Returns</dt><dd>2 raised to the power of x. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9aee32f9e268b7135c66fc1fb887f44a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ScalarUnit &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dimensionless::scalar_t units::math::expm1 </td>
          <td>(</td>
          <td class="paramtype">const ScalarUnit&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute exponential minus one. </p>
<p>Returns e raised to the power x minus one: e^x-1. For small magnitude values of x, expm1 may be more accurate than exp(x)-1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Value of the exponent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>e raised to the power of x, minus one. </dd></dl>

</div>
</div>
<a class="anchor" id="gaae0bd34663a2828665567af99a97fb24"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UnitType , class  = std::enable_if_t&lt;traits::is_unit_t&lt;UnitType&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UnitType units::math::fabs </td>
          <td>(</td>
          <td class="paramtype">const UnitType&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute absolute value. </p>
<p>Returns the absolute value of x, i.e. |x|. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Value whose absolute value is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The absolute value of x. </dd></dl>

</div>
</div>
<a class="anchor" id="ga75fe15cca375d6f73fd1b797d491119d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UnitTypeLhs , class UnitTypeRhs , class  = std::enable_if_t&lt;traits::is_unit_t&lt;UnitTypeLhs&gt;::value &amp;&amp; traits::is_unit_t&lt;UnitTypeRhs&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UnitTypeLhs units::math::fdim </td>
          <td>(</td>
          <td class="paramtype">const UnitTypeLhs&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnitTypeRhs&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Positive difference. </p>
<p>The function returns x-y if x&gt;y, and zero otherwise, in the same units as x. Values x and y do not have to be the same type of units, but they do have to be compatible. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Values whose difference is calculated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Values whose difference is calculated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The positive difference between x and y. </dd></dl>

</div>
</div>
<a class="anchor" id="gad7fa514c186141cb9d3fcf824fd41a37"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UnitType , class  = std::enable_if_t&lt;traits::is_unit_t&lt;UnitType&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UnitType units::math::floor </td>
          <td>(</td>
          <td class="paramtype">const UnitType&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Round down value. </p>
<p>Rounds x downward, returning the largest integral value that is not greater than x. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Unit value to round down. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of x rounded downward. </dd></dl>

</div>
</div>
<a class="anchor" id="ga007637a66a15b39d44af325ddf8d754c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UnitTypeLhs , class UnitMultiply , class UnitAdd , class  = std::enable_if_t&lt;traits::is_unit_t&lt;UnitTypeLhs&gt;::value &amp;&amp; traits::is_unit_t&lt;UnitMultiply&gt;::value &amp;&amp; traits::is_unit_t&lt;UnitAdd&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto units::math::fma </td>
          <td>(</td>
          <td class="paramtype">const UnitTypeLhs&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnitMultiply&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnitAdd&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(x * y)
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply-add. </p>
<p>Returns x*y+z. The function computes the result without losing precision in any intermediate result. The resulting unit type is a compound unit of x* y. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Values to be multiplied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Values to be multiplied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>Value to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of x*y+z </dd></dl>

</div>
</div>
<a class="anchor" id="ga133b8c692d6dbf2d19f27adb13ce6ecf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UnitTypeLhs , class UnitTypeRhs , class  = std::enable_if_t&lt;traits::is_unit_t&lt;UnitTypeLhs&gt;::value &amp;&amp; traits::is_unit_t&lt;UnitTypeRhs&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UnitTypeLhs units::math::fmax </td>
          <td>(</td>
          <td class="paramtype">const UnitTypeLhs&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnitTypeRhs&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum value. </p>
<p>Returns the larger of its arguments: either x or y, in the same units as x. Values x and y do not have to be the same type of units, but they do have to be compatible. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Values among which the function selects a maximum. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Values among which the function selects a maximum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum numeric value of its arguments. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2c7353469775440d04f98655e3a9e065"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UnitTypeLhs , class UnitTypeRhs , class  = std::enable_if_t&lt;traits::is_unit_t&lt;UnitTypeLhs&gt;::value &amp;&amp; traits::is_unit_t&lt;UnitTypeRhs&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UnitTypeLhs units::math::fmin </td>
          <td>(</td>
          <td class="paramtype">const UnitTypeLhs&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnitTypeRhs&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum value. </p>
<p>Returns the smaller of its arguments: either x or y, in the same units as x. If one of the arguments in a NaN, the other is returned. Values x and y do not have to be the same type of units, but they do have to be compatible. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Values among which the function selects a minimum. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Values among which the function selects a minimum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum numeric value of its arguments. </dd></dl>

</div>
</div>
<a class="anchor" id="ga50270995c6f9ca902fcdc2daf8edc784"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UnitTypeLhs , class UnitTypeRhs , class  = std::enable_if_t&lt;traits::is_unit_t&lt;UnitTypeLhs&gt;::value &amp;&amp; traits::is_unit_t&lt;UnitTypeRhs&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UnitTypeLhs units::math::fmod </td>
          <td>(</td>
          <td class="paramtype">const UnitTypeLhs&#160;</td>
          <td class="paramname"><em>numer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnitTypeRhs&#160;</td>
          <td class="paramname"><em>denom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute remainder of division. </p>
<p>Returns the floating-point remainder of numer/denom (rounded towards zero). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numer</td><td>Value of the quotient numerator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">denom</td><td>Value of the quotient denominator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The remainder of dividing the arguments. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3162ba1ab8f84bcd2d17cbe60769b851"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UnitTypeLhs , class UnitTypeRhs , std::enable_if_t&lt; units::traits::has_linear_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UnitTypeLhs units::math::hypot </td>
          <td>(</td>
          <td class="paramtype">const UnitTypeLhs &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnitTypeRhs &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of the sum-of-squares of x and y. </p>
<p>Only implemented for <a class="el" href="structunits_1_1linear__scale.html" title="unit_t scale which is linear ">linear_scale</a> units. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td><a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> type value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td><a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a> type value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>square root of the sum-of-squares of x and y in the same units as x. </dd></dl>

</div>
</div>
<a class="anchor" id="gaed3e6783dc5ab1dda006913aa53f17c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ScalarUnit &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dimensionless::scalar_t units::math::log </td>
          <td>(</td>
          <td class="paramtype">const ScalarUnit&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute natural logarithm. </p>
<p>Returns the natural logarithm of x. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>scalar value whose logarithm is calculated. If the argument is negative, a domain error occurs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___unit_math.html#gaf02e920d1b57574f1c8ae3974d1e3c80" title="Compute common logarithm. ">log10</a> for more common base-10 logarithms </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Natural logarithm of x. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf02e920d1b57574f1c8ae3974d1e3c80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ScalarUnit &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dimensionless::scalar_t units::math::log10 </td>
          <td>(</td>
          <td class="paramtype">const ScalarUnit&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute common logarithm. </p>
<p>Returns the common (base-10) logarithm of x. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Value whose logarithm is calculated. If the argument is negative, a domain error occurs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Common logarithm of x. </dd></dl>

</div>
</div>
<a class="anchor" id="gaef69e3da7b1cf820853dc8bb5043e1e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ScalarUnit &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dimensionless::scalar_t units::math::log1p </td>
          <td>(</td>
          <td class="paramtype">const ScalarUnit&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute logarithm plus one. </p>
<p>Returns the natural logarithm of one plus x. For small magnitude values of x, logp1 may be more accurate than log(1+x). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Value whose logarithm is calculated. If the argument is less than -1, a domain error occurs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The natural logarithm of (1+x). </dd></dl>

</div>
</div>
<a class="anchor" id="gac19a3f10ebced4d7760193130ed220fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ScalarUnit &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dimensionless::scalar_t units::math::log2 </td>
          <td>(</td>
          <td class="paramtype">const ScalarUnit&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute binary logarithm. </p>
<p>Returns the binary (base-2) logarithm of x. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Value whose logarithm is calculated. If the argument is negative, a domain error occurs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binary logarithm of x: log2x. </dd></dl>

</div>
</div>
<a class="anchor" id="ga84d1ea9cad48f0b77cf892633240e4a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ScalarUnit &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dimensionless::scalar_t units::math::modf </td>
          <td>(</td>
          <td class="paramtype">const ScalarUnit&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarUnit *&#160;</td>
          <td class="paramname"><em>intpart</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Break into fractional and integral parts. </p>
<p>The integer part is stored in the object pointed by intpart, and the fractional part is returned by the function. Both parts have the same sign as x. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>scalar value to break into parts. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intpart</td><td>Pointer to an object (of the same type as x) where the integral part is stored with the same sign as x. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The fractional part of x, with the same sign. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3e417de9376e1fc58cd07a8465c7e9c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UnitType , class  = std::enable_if_t&lt;traits::is_unit_t&lt;UnitType&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UnitType units::math::round </td>
          <td>(</td>
          <td class="paramtype">const UnitType&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Round to nearest. </p>
<p>Returns the integral value that is nearest to x, with halfway cases rounded away from zero. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>value to round. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of x rounded to the nearest integral. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf0a50351f8f51550d00e9831b60e1850"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AngleUnit &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dimensionless::scalar_t units::math::sin </td>
          <td>(</td>
          <td class="paramtype">const AngleUnit&#160;</td>
          <td class="paramname"><em>angle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute sine. </p>
<p>The input value can be in any unit of angle, including radians or degrees. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">AngleUnit</td><td>any <code><a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a></code> type of <code>catgeory::angle_unit</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">angle</td><td>angle to compute the since of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the sine of <em>angle</em> </dd></dl>

</div>
</div>
<a class="anchor" id="ga38584a9aa9ecbcf455f1a75b23fc8495"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AngleUnit &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dimensionless::scalar_t units::math::sinh </td>
          <td>(</td>
          <td class="paramtype">const AngleUnit&#160;</td>
          <td class="paramname"><em>angle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute hyperbolic sine. </p>
<p>The input value can be in any unit of angle, including radians or degrees. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">AngleUnit</td><td>any <code><a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a></code> type of <code>catgeory::angle_unit</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">angle</td><td>angle to compute the hyperbolic sine of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the hyperbolic sine of <em>angle</em> </dd></dl>

</div>
</div>
<a class="anchor" id="ga2c190a6f34676262b59c06423e27e1d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UnitType , std::enable_if_t&lt; units::traits::has_linear_scale&lt; UnitType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto units::math::sqrt </td>
          <td>(</td>
          <td class="paramtype">const UnitType &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt;<a class="el" href="group___unit_manipulators.html#gad6fb385c468a9f9956d23ebc7c38523a">square_root</a>&lt;typename units::traits::unit_t_traits&lt;UnitType&gt;::unit_type&gt;, typename units::traits::unit_t_traits&lt;UnitType&gt;::underlying_type, <a class="el" href="structunits_1_1linear__scale.html">linear_scale</a>&gt;
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes the square root of <em>value</em> </p>
<p>Only implemented for <a class="el" href="structunits_1_1linear__scale.html" title="unit_t scale which is linear ">linear_scale</a> units. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td><code><a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a></code> derived type to compute the square root of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a>, whose units are the square root of value's. E.g. if values had units of <code>square_meter</code>, then the return type will have units of <code>meter</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>sqrt</code> provides a <em>rational approximation</em> of the square root of <em>value</em>. In some cases, <em>both</em> the returned value <em>and</em> conversion factor of the returned unit type may have errors no larger than <code>1e-10</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4a0bd68dee584d4b0b12c49bec0706c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AngleUnit &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dimensionless::scalar_t units::math::tan </td>
          <td>(</td>
          <td class="paramtype">const AngleUnit&#160;</td>
          <td class="paramname"><em>angle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute tangent. </p>
<p>The input value can be in any unit of angle, including radians or degrees. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">AngleUnit</td><td>any <code><a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a></code> type of <code>catgeory::angle_unit</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">angle</td><td>angle to compute the tangent of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the tangent of <em>angle</em> </dd></dl>

</div>
</div>
<a class="anchor" id="gaca6a60340c678dcce1c2e4afc52f3c9d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AngleUnit &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dimensionless::scalar_t units::math::tanh </td>
          <td>(</td>
          <td class="paramtype">const AngleUnit&#160;</td>
          <td class="paramname"><em>angle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute hyperbolic tangent. </p>
<p>The input value can be in any unit of angle, including radians or degrees. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">AngleUnit</td><td>any <code><a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit. ">unit_t</a></code> type of <code>catgeory::angle_unit</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">angle</td><td>angle to compute the hyperbolic tangent of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the hyperbolic tangent of <em>angle</em> </dd></dl>

</div>
</div>
<a class="anchor" id="gae0019fd57476802def84991c48fe8e66"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UnitType , class  = std::enable_if_t&lt;traits::is_unit_t&lt;UnitType&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UnitType units::math::trunc </td>
          <td>(</td>
          <td class="paramtype">const UnitType&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Truncate value. </p>
<p>Rounds x toward zero, returning the nearest integral value that is not larger in magnitude than x. Effectively rounds towards 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Value to truncate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The nearest integral value that is not larger in magnitude than x. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Feb 13 2017 14:15:41 for Unit Conversion and Dimensional Analysis Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
